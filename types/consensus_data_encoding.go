// Code generated by fastssz. DO NOT EDIT.
// Hash: 18ad6580deb31bb4ab305f571c5b34bf9120c182ced0523c7bc6a9b05e68b480
package types

import (
	"github.com/attestantio/go-eth2-client/spec/altair"
	"github.com/attestantio/go-eth2-client/spec/bellatrix"
	"github.com/attestantio/go-eth2-client/spec/phase0"
	ssz "github.com/ferranbt/fastssz"
	"github.com/pkg/errors"
)

func (cd *ConsensusData) MarshalSSZ() ([]byte, error) {
	var marshalSSZ []byte
	var err error
	switch cd.Duty.Type {
	case BNRoleAttester:
		marshalSSZ, err = cd.AttestationData.MarshalSSZ()
		if err != nil {
			return nil, err
		}
	case BNRoleAggregator:
		marshalSSZ, err = cd.AggregateAndProof.MarshalSSZ()
		if err != nil {
			return nil, err
		}
	case BNRoleProposer:
		marshalSSZ, err = cd.BlockData.MarshalSSZ()
		if err != nil {
			return nil, err
		}
	case BNRoleSyncCommittee:
		marshalSSZ = append(marshalSSZ, cd.SyncCommitteeBlockRoot[:]...)
	case BNRoleSyncCommitteeContribution:
		var ce contributionEntries
		if len(cd.SyncCommitteeContribution) > 0 {
			ce.SyncCommitteeContribution = make([]*ContributionEntry, 0, len(cd.SyncCommitteeContribution))

			for k, v := range cd.SyncCommitteeContribution {
				ce.SyncCommitteeContribution = append(ce.SyncCommitteeContribution, &ContributionEntry{
					Sig:   k,
					Contr: v,
				})
			}
		}
		marshalSSZ, err = ce.MarshalSSZ()
		if err != nil {
			return nil, err
		}
	default:
		return nil, errors.New("unknown role")
	}

	return ssz.MarshalSSZ(&ConsensusInput{
		Duty: cd.Duty,
		Data: marshalSSZ,
	})
}

// MarshalSSZTo ssz marshals the ConsensusData object to a target array
func (cd *ConsensusData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	return nil, nil
}

// UnmarshalSSZ ssz unmarshals the ConsensusData object
func (cd *ConsensusData) UnmarshalSSZ(buf []byte) error {
	var cdSSZ ConsensusInput
	if err := cdSSZ.UnmarshalSSZ(buf); err != nil {
		return err
	}

	cd.Duty = cdSSZ.Duty

	var err error
	switch cd.Duty.Type {
	case BNRoleAttester:
		var attestationData phase0.AttestationData
		if err = attestationData.UnmarshalSSZ(cdSSZ.Data); err != nil {
			return err
		}
		cd.AttestationData = &attestationData
	case BNRoleAggregator:
		var aggregateAndProof phase0.AggregateAndProof
		if err = aggregateAndProof.UnmarshalSSZ(cdSSZ.Data); err != nil {
			return err
		}
		cd.AggregateAndProof = &aggregateAndProof
	case BNRoleProposer:
		var blockData bellatrix.BeaconBlock
		if err = blockData.UnmarshalSSZ(cdSSZ.Data); err != nil {
			return err
		}
		cd.BlockData = &blockData
	case BNRoleSyncCommittee:
		copy(cd.SyncCommitteeBlockRoot[:], cdSSZ.Data)
	case BNRoleSyncCommitteeContribution:
		var ce contributionEntries
		if err = ce.UnmarshalSSZ(cdSSZ.Data); err != nil {
			return err
		}
		var contributionMap ContributionsMap
		if len(ce.SyncCommitteeContribution) > 0 {
			contributionMap = make(ContributionsMap)
			for _, s := range ce.SyncCommitteeContribution {
				contributionMap[s.Sig] = s.Contr
			}
		}
		cd.SyncCommitteeContribution = contributionMap
	default:
		return errors.New("unknown role")
	}

	return nil
}

// SizeSSZ returns the ssz encoded size in bytes for the ConsensusData object
func (cd *ConsensusData) SizeSSZ() (size int) {
	size = 101

	switch cd.Duty.Type {
	case BNRoleAttester:
		size += cd.AttestationData.SizeSSZ()
	case BNRoleAggregator:
		size += cd.AggregateAndProof.SizeSSZ()
	case BNRoleProposer:
		size += cd.BlockData.SizeSSZ()
	case BNRoleSyncCommittee:
		size += len(cd.SyncCommitteeBlockRoot)
	case BNRoleSyncCommitteeContribution:
		sccSlice := make([]*ContributionEntry, 0, len(cd.SyncCommitteeContribution))

		for key, value := range cd.SyncCommitteeContribution {
			sccSlice = append(sccSlice, &ContributionEntry{
				Sig:   key,
				Contr: value,
			})
		}

		for ii := 0; ii < len(sccSlice); ii++ {
			size += 4
			size += sccSlice[ii].SizeSSZ()
		}
	}

	return
}

// MarshalSSZ ssz marshals the ConsensusInput object
func (c *ConsensusInput) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the ConsensusInput object to a target array
func (c *ConsensusInput) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'Duty'
	dst = ssz.WriteOffset(dst, offset)
	if c.Duty == nil {
		c.Duty = new(Duty)
	}
	offset += c.Duty.SizeSSZ()

	// Offset (1) 'Data'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.Data)

	// Field (0) 'Duty'
	if dst, err = c.Duty.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Data'
	if len(c.Data) > 387068 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, c.Data...)

	return
}

// UnmarshalSSZ ssz unmarshals the ConsensusInput object
func (c *ConsensusInput) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'Duty'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 8 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Data'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'Duty'
	{
		buf = tail[o0:o1]
		if c.Duty == nil {
			c.Duty = new(Duty)
		}
		if err = c.Duty.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Data'
	{
		buf = tail[o1:]
		if len(buf) > 387068 {
			return ssz.ErrBytesLength
		}
		if cap(c.Data) == 0 {
			c.Data = make([]byte, 0, len(buf))
		}
		c.Data = append(c.Data, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ConsensusInput object
func (c *ConsensusInput) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'Duty'
	if c.Duty == nil {
		c.Duty = new(Duty)
	}
	size += c.Duty.SizeSSZ()

	// Field (1) 'Data'
	size += len(c.Data)

	return
}

// HashTreeRoot ssz hashes the ConsensusInput object
func (c *ConsensusInput) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the ConsensusInput object with a hasher
func (c *ConsensusInput) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Duty'
	if err = c.Duty.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Data'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.Data))
		if byteLen > 387068 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(c.Data)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (387068+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the contributionEntries object
func (c *contributionEntries) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the contributionEntries object to a target array
func (c *contributionEntries) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'SyncCommitteeContribution'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(c.SyncCommitteeContribution); ii++ {
		offset += 4
		offset += c.SyncCommitteeContribution[ii].SizeSSZ()
	}

	// Field (0) 'SyncCommitteeContribution'
	if len(c.SyncCommitteeContribution) > 13 {
		err = ssz.ErrListTooBig
		return
	}
	{
		offset = 4 * len(c.SyncCommitteeContribution)
		for ii := 0; ii < len(c.SyncCommitteeContribution); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += c.SyncCommitteeContribution[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(c.SyncCommitteeContribution); ii++ {
		if dst, err = c.SyncCommitteeContribution[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the contributionEntries object
func (c *contributionEntries) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'SyncCommitteeContribution'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'SyncCommitteeContribution'
	{
		buf = tail[o0:]
		num, err := ssz.DecodeDynamicLength(buf, 13)
		if err != nil {
			return err
		}
		c.SyncCommitteeContribution = make([]*ContributionEntry, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if c.SyncCommitteeContribution[indx] == nil {
				c.SyncCommitteeContribution[indx] = new(ContributionEntry)
			}
			if err = c.SyncCommitteeContribution[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the contributionEntries object
func (c *contributionEntries) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'SyncCommitteeContribution'
	for ii := 0; ii < len(c.SyncCommitteeContribution); ii++ {
		size += 4
		size += c.SyncCommitteeContribution[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the contributionEntries object
func (c *contributionEntries) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the contributionEntries object with a hasher
func (c *contributionEntries) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'SyncCommitteeContribution'
	{
		subIndx := hh.Index()
		num := uint64(len(c.SyncCommitteeContribution))
		if num > 13 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range c.SyncCommitteeContribution {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 13)
	}

	hh.Merkleize(indx)
	return
}

// MarshalSSZ ssz marshals the ContributionEntry object
func (c *ContributionEntry) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the ContributionEntry object to a target array
func (c *ContributionEntry) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(100)

	// Field (0) 'Sig'
	dst = append(dst, c.Sig[:]...)

	// Offset (1) 'Contr'
	dst = ssz.WriteOffset(dst, offset)
	if c.Contr == nil {
		c.Contr = new(altair.SyncCommitteeContribution)
	}
	offset += c.Contr.SizeSSZ()

	// Field (1) 'Contr'
	if dst, err = c.Contr.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ContributionEntry object
func (c *ContributionEntry) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 100 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'Sig'
	copy(c.Sig[:], buf[0:96])

	// Offset (1) 'Contr'
	if o1 = ssz.ReadOffset(buf[96:100]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 100 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Contr'
	{
		buf = tail[o1:]
		if c.Contr == nil {
			c.Contr = new(altair.SyncCommitteeContribution)
		}
		if err = c.Contr.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ContributionEntry object
func (c *ContributionEntry) SizeSSZ() (size int) {
	size = 100

	// Field (1) 'Contr'
	if c.Contr == nil {
		c.Contr = new(altair.SyncCommitteeContribution)
	}
	size += c.Contr.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the ContributionEntry object
func (c *ContributionEntry) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the ContributionEntry object with a hasher
func (c *ContributionEntry) HashTreeRootWith(hh *ssz.Hasher) (err error) {
	indx := hh.Index()

	// Field (0) 'Sig'
	hh.PutBytes(c.Sig[:])

	// Field (1) 'Contr'
	if err = c.Contr.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}